---
title: 'NestJS Tutorial Part I: Basics and Dependency Injection'
date: '2021-12-13'
modified: '2021-12-27'
description: 'The first part of the NestJS tutorial series includes the basics, modules, and controllers as well as dependency inversion principle and dependency injection.'
cover: '/posts/covers/nestjs-tutorial-I.webp'
slug: 'nestjs-tutorial-I'
topic: 'code'
canonical: 'https://www.cbsofyalioglu.com/code/nestjs-tutorial-I/'
language: 'eng'
categories:
    - 'code'
    - 'post'
    - 'featured'
tags:
    - 'nestjs basics'
    - 'nestjs modules'
    - 'nestjs controllers'
    - 'nestjs data validations'
    - 'nestjs dependency injection'
    - "dependency inversion principle"
    - "dependency injection"
    - "inversion of control"
    - "dependency inversion container"
    - "IoC container"
keywords:
    - 'nestjs tutorial'
    - 'nestjs introduction'
    - 'nestjs for starters'
    - 'nestjs basics'
    - "dependency inversion principle"
    - "dependency injection"
    - "inversion of control"
    - "dependency inversion container"
    - "IoC container"
related:
    - 'adonisjs-solidjs'
    - 'solidjs-and-reactive-primitives'
    - 'free-design-resources'
    - 'content-creation-tools'
proficiencyLevel: 'Beginner'
---

import { ImageZoom } from '/components/mdx/image'

I'm currently learning Nest.JS framework and because I organized my notes very well I decided to share them in this **NestJS tutorial** post.

I'm planning to make a boilerplate app with throughout this Nest.JS tutorial. The app will cover a simple authentication.


In this part, I'm going to try to explain basics of Nest and its basic concepts.

Since understanding NestJS requires some software development concepts, I will try to explain those concepts also:
- Decorators
- Dependency Inversion Principle
- Dependency Injection
- Inversion of Control



# 1) Introduction

For the demonstration purposes, let's look some basics of NestJS. You don't need to do anything rightnow until the next sextion. (We are going to create a Nest.js project with the CLI in the next section)


### 1.1) NestJS Packages

When you create a new project from scratch you need to install the libraries below.

```bash
# install dependencies
npm install @nestjs/common @nestjs/core @nestjs/platform-express reflect-metadata typescript
```

Let's look what are those for:

| Package                  | Description                                                                                                                     |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| @nestjs/common           | The functions, classes and other useful stuff except the core package.                                                          |
| @nestjs/core             | The core package of NestJS.                                                                                                     |
| @nestjs/platform-express | Express library for handling HTTP requests. You can also choose Fastify as well.                                                |
| reflect-metadata         | It is for using decorators.                                                                                                     |
| typescript               | The package is required for using the superset of JavaScript. It is required since we are going to write our app in TypeScript. |

### 1.2) TypeScript Configurations

NestJS is heavily uses decorators which is a [feature of TypeScript](https://www.typescriptlang.org/docs/handbook/decorators.html). Decorators allows us to write cleaner and understandable code. You can also read: [Understanding JavaScript decorators](https://blog.logrocket.com/understanding-javascript-decorators/)

```bash
{
    "compilerOptions": {
        "target": "es2017", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 'ES2021', or 'ESNEXT'. */
        "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
        "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */
        "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */
    }
}
```

### 1.3) NestJS Concepts

| NestJS Tool  | Description                                                  |
| ------------ | ------------------------------------------------------------ |
| Pipe         | Data validation in requests                                  |
| Guard        | User authentication                                          |
| Modules      | Groups the code together. A module wraps the controller.     |
| Controller   | Route the request to a specific function                     |
| Service      | Business logic                                               |
| Repository   | Database access                                              |
| Filters      | Handles errors that occur during request handling            |
| Interceptors | Adds extra logic to incoming requests or outcoming responses |



### 1.4) Creating a project with the CLI

Another way of starting a NestJS project is scaffolidng with the [Nest CLI](https://docs.nestjs.com/cli/overview).

```bash
# install Nest CLI
npm i -g @nestjs/cli

# create a project
nest new nest-tutorial
```

```bash
# after installation change your directory
cd nest-tutorial

# start development server
npm run start:dev
```
You can visit `http://localhost:3000` on your browser. You'll see that our app is running.

### 1.5) The Basic App Structure

After installation, we will see the default file structure and simple explanations taken from [the official document](https://docs.nestjs.com/first-steps).

![NestJS default file structure](/posts/dependency-inversion/nestjs-default-file-structure.png)

| Filename               | Description                                                                                                       |     |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------- | --- |
| app.controller.ts      | A basic controller with a single route.                                                                           |     |
| app.controller.spec.ts | The unit tests for the controller.                                                                                |     |
| app.module.ts          | The root module of the application.                                                                               |     |
| app.service.ts         | A basic service with a single method.                                                                             |     |
| main.ts                | The entry file of the application which uses the core function NestFactory to create a Nest application instance. |     |


<br/>

---
---

## 2) A Nest.JS Tutorial Project

### 2.1) Underlying Server and the Entrypoint
Nest aims to be a platform-agnostic framework. It works with any NodeJS server. However, out-of-the-box, it supports Express and Fastify.

Those platform-specific configurations and the most general NestJS configurations can be done with the app's entry point.

Let's look `main.ts` file which is the entry point of the app.


<ImageZoom
    src="/posts/nestjs/entrypoint.webp"
    width="796"
    height="443"
    alt="The entrypoint of Nest app"
/>

A Nest application can be created with the `NestFactory`'s `create` method which returns an app object that fulfills the  [INestApplication](https://github.com/nestjs/nest/blob/master/packages/common/interfaces/nest-application.interface.ts) interface.

Later on, we will use some of the methods of the returned app object such as `GlobalGuards`, `GlobalPipes`, `GlobalInterceptors`, etc...

By default, NestJS uses Express as its default Node server. You can use [Fastify with NestJS](https://docs.nestjs.com/techniques/performance) as well as other Node servers.

<br/>

---

<ImageZoom
    src="/posts/nestjs/modules.webp"
    width="1400"
    height="350"
    alt="Modules in NestJS"
/>

### 2.2) Modules in NestJS
In Nest.js, every app has at least one module. Modules encapsulate closely related code components together. It is strongly suggested to use modules for organizing your code. By doing that, you can easily scale your code.

A module is a class annotated with a `@Module()` decorator. In other words, we use `@Module()` decorator with an object, in order to make a class a module.

<ImageZoom
    src="/posts/nestjs/root-module.webp"
    width="774"
    height="489"
    alt="The basic concepts of NestJS"
/>

#### 2.2.1) The Root module
When you create a Nest app with the CLI, the root module of your app will be in `app.module.ts` file.

```ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

---

<br/>

<br/>

<ImageZoom
    src="/posts/nestjs/decorators.webp"
    width="1400"
    height="350"
    alt="Decorators in NestJS"
/>

#### 2.2.2) What is a decorator?
Decorator is a concept that related with [Decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern) which is a design pattern in object-oriented programming.

Decorators are functions that let you attach new behaviors to objects by placing these objects inside a special wrapper.

Decorators are currently "stage 2 proposal" for JavaScript. However, TypeScript supports using decorators. You can use 5 types of decorators in TypeScript:
- Property Decorators
- Method Decorators
- Accessor Decorators
- Parameter Decorators and
- Class Decorators, like we use in modules.

<ImageZoom
    src="/posts/nestjs/class-decorator.avif"
    width="700"
    height="350"
    alt="The basic concepts of NestJS"
/>

A class decorator is applied to the constructor of a class. It can observe, modify or replace a class definition.
Also, it should be noted that a class decorator can not be used in a TypeScript declaration file.

<br/>

For the details, you can check [Decorators in TypeScript](https://www.typescriptlang.org/docs/handbook/decorators.html)


You can also read this excellent article: [A complete guide to TypeScript Decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/)

Let's back to the modules.


---

#### 2.2.3) Properties of the Module object


I said that a module decorator takes a single object. The properties of the object describe the module.


| Property    | Description                                                                                                                                                                                          |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| providers   | the providers that will be instantiated by the Nest injector and that may be shared at least across this module                                                                                      |
| controllers | the set of controllers defined in this module which have to be instantiated                                                                                                                          |
| imports     | the list of imported modules that export the providers which are required in this module                                                                                                             |
| exports     | the subset of providers that are provided by this module and should be available in other modules which import this module. You can use either the provider itself or just its token (provide value) |








#### 2.2.4) Notes on Modules

Some important things about the modules in NestJS:
- Modules use singleton design pattern. Therefore we can share the instance of any service provider between modules.
- Every module is automatically a shared module. Once created it can be reused by any module.
- We need to import its module first when we need to use any provider.
- Any module imported to another module also can be exported from.
- Because providers aren't registered in global scope, importing a specific module many times can be tedious. You can go around this problem by adding `@Global`decorator to a module (except [lazy-loaded modules](https://docs.nestjs.com/fundamentals/lazy-loading-modules)).

#### 2.2.5) Create a new module with the CLI
Let's create a new module that will be responsible for the users of our app. If your Nest.JS app is running, you can stop it by pressing `CMD/CTRL + C`.

In your terminal, execute the commands below:
```bash
nest generate module users
```

This will create `users` folder under `src` directory. Under this directory, you'll see `users.module.ts` file.

```ts
import { Module } from '@nestjs/common';

@Module({})
export class UsersModule {}
```



The module file is empty now. Let's fill it with some code components.

---

<ImageZoom
    src="/posts/nestjs/controllers.webp"
    width="1400"
    height="350"
    alt="Controllers in NestJS"
/>

### 2.3) Controllers in NestJS
I previously said that a controller is responsible for routing a request to a specific function. Controllers are connected our app through a module.

There is a better way to create controller and resources than what we will do. Since this is a *tutorial about NestJS*, I am going to do many tasks manually.
Otherwise,  you can [quickly create a CRUD API](https://docs.nestjs.com/recipes/crud-generator#crud-generator).

Let's create a controller.

```bash
nest generate controller users/users --flat
```

When you execute the command above, two new files will be generated: `users.controller.ts` and `users.controller.spec.ts`. The latter one is for test purposes and thus we can skip it now.

```ts
import { Controller} from '@nestjs/common';

@Controller('users')
export class UsersController {}
```


#### 2.3.1) Notes on creating a controller

Also, please check the `users.module.ts` file. You can see that the new controller is automatically appended to its module.

```ts
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';

@Module({
  controllers: [UsersController],
  imports: []
})
export class UsersModule {}
```

There are some things to be highlighted:

1. Don't add contoller suffix to your controller name. It will be automatically suffixed.
2. Putting --flat flag generates the controller without creating an extra folder. If you need more organized directory which put controller in a folder, you can omit it.
3. The controller is automatically appended to the module
4. The text in the controller decorator, which is "users" in our case, prefixes the routes under the controller. In other words, all the routes under this controller will start with `users` such as `/users/:id`.

<br/>

#### 2.3.2) Adding routes
We created a very basic controller.
We need to add routes with the corresponding HTTP request. We should specify HTTP requests with decorators.  `@Get()`,  `@Post()`,  `@Put()`  `@Delete()`,  `@Patch()`, `@Options()`,  `@Head()`, `@All()`.

<br />

Let's create a CRUD API.

```ts
import { Controller, Get, Post, Delete, Patch } from '@nestjs/common';

@Controller('users')
export class UsersController {
  @Get()
  getAllUsers() {
    // we will fill it soon
  }

  @Post()
  createUser() {
    // we will fill it soon
  }

  @Get('/:id')
  getUser(id: number) {
    // we will fill it soon
  }

  @Patch('/:id')
  updateUser() {
    // we will fill it soon
  }

  @Delete('/:id')
  removeUser() {
    // we will fill it soon
  }
}
```

| Request | Function    | Endpoint     |
| ------- | ----------- | ------------ |
| GET     | getAllUsers | "/users/"    |
| POST    | createUser  | "/users/"    |
| GET     | getUser     | "/users/:id" |
| Patch   | updateUser  | "/users/:id" |
| Delete  | removeUser  | "/users/:id" |

<br/>

---

#### 2.3.3) REST API Client

To check our routes, there are several ways. You can use your favorite REST API Client such as Postman, Insomnia, Paw. I'm planning to use [Thunder Client](https://www.thunderclient.io/) throughout this post. It is an extension for VS Code. If you are a VS Coder, the chances are high that you like it.

<ImageZoom
    src="/posts/nestjs/thunder-client.webp"
    width="1400"
    height="700"
    alt="Thunder Client NestJS Routes"
/>


For the detailed instructions, you can visit: [NestJS Controllers - Routing](https://docs.nestjs.com/controllers#routing).

<br/>

Since a controller method will be responsible only for routing, we need to create a service that will handle the business logic of our app.

---


## Creating a Provider
Providers are a fundamental concept in Nest. Many of the basic Nest classes may be treated as a provider – services, repositories, factories, helpers, and so on.

### Services and Repositories
Services and repositories are tightly connected concepts. Basically, a service is a class where we do business logic. Repositories, on the other hand, are responsible for database access.
A service can use one or more repositories to get different data and combine them together.

A repository is simply a wrapper for a database. It can wrap an ORM like [TypeORM](https://typeorm.io/), [Prisma](https://www.prisma.io/), or [Sequelize](https://sequelize.org/) or an ODM like [Mongoose](https://mongoosejs.com/) schema.



Let's create a service provider that will handle business logic of the users and a repository file that is responsible for database access.

```bash
# create a file for the service
touch src/users/users.service.ts

# create a file for the repository
touch src/users/users.repository.ts
```

<br/>

Before filling those files, let's read [providers section of the official documents](https://docs.nestjs.com/providers):
>The main idea of a provider is that it can be injected as dependency; this means objects can create various relationships with each other, and the function of "wiring up" instances of objects can largely be delegated to the Nest runtime system.

What is injection? Hmm.. Let's understand the most important part of the NestJS.

---


### 2.4) Dependency Inversion Principle and Dependency Injection


#### 2.4.1) Dependency Inversion Principle
[Dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)  is one of the five design principles of [SOLID principles](https://en.wikipedia.org/wiki/SOLID). The principle states that:
- High-level modules should not import anything from low-level modules. Both should depend on abstractions (e.g., interfaces).
- Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.

<br/>

> One of the goals of these methods is to define the subprogram hierarchy that describes how the high-level modules make calls to the low-level modules.

\- Agile Software Development, Principles, Patterns, and Practices. Robert C. Martin

Also, you can read the [article of Robert C. Martin](https://web.archive.org/web/20041221102842/http://www.objectmentor.com/resources/articles/dip.pdf).



<br/>

#### 2.4.2) Reviewing the module structure

It is better to read the concept with an implementation. In our example,
- `Users` module which is a distinct part of our app will encapsulate closely related modules and classes inside of it.
- `UsersController` is responsible for routing a request to a particular function.
- `UsersService` is class that we put business logic in it.
- `UsersRepository` is another class responsible for database access.

It should also be noted that:
- `UsersController` depends on `UsersService` which also depends on `UsersRepository`.


<ImageZoom
    src="/posts/dependency-inversion/users-dependency-1400x350.webp"
    width="1400"
    height="350"
    alt="NestJS default file structure"
/>

<br/>

One of the way for creating a service provider for the controller is like that:

```ts
// OPTION I (❌ BAD)
export class UsersService {
    usersRepo: UsersRepository;

    constructor() {
        this.usersRepo = new UsersRepository();
    }
}
```

<br/>

#### 2.4.3) The dependency problem of the provider

There are some problems in the code above. I will try to explain those.

In the future, another controller may require `UsersService`. Since the service creates the instance of its dependency, there will be many instances of `UsersRepository` which means many database connections.


<ImageZoom
    src="/posts/dependency-inversion/instances-should-not-create-their-own-dependencies-1400x700.webp"
    width="1400"
    height="700"
    alt="Code organization in Nest.JS"
/>

##### A Higher level module depends on a lower level module
It is difficult to reuse a higher level module (`UsersService`) that depends on a lower level module (`UsersRepository`) in a different context. Otherwise, our system will become more rigid and fragile.

<ImageZoom
    src="/posts/dependency-inversion/users-dependency-fail-1400x350.webp"
    width="1400"
    height="350"
    alt="Dependency inversion"
/>

<br/>

Also, the methods of the provider will be determined by a lower level module. Therefore, the `UsersService` will be flexible as much as `UsersRepository`.

If there is a problem to access `UsersRepository`, then we will have a problem in `UsersService`. Since `UsersController` tightly depends on `UsersService`, our controller will also fail.

<ImageZoom
    src="/posts/dependency-inversion/low-level-to-high-level-1400x700.webp"
    width="1400"
    height="700"
    alt="Dependency inversion 2"
/>
<br/>

Moreover, if we need to change the code of the lower level module, we always need to change the higher level module.

<ImageZoom
    src="/posts/dependency-inversion/low-level-changes-forces-to-high-level-module-1400x700.webp"
    width="1400"
    height="700"
    alt="Dependency inversion 3"
/>

<br/>

Considering these problems, let's make our code better.

```ts
/**
 * OPTION II (✅  BETTER)
 * An instance of UsersService gets its exact dependency
 * at its creation rather than creating a new instance of UsersRepository.
 */
export class UsersService {
    usersRepo: UsersRepository;

    constructor(repo: UsersRepository) {
        this.usersRepo = repo
    }
}
```

##### A concrete implementation doesn't depend on abstraction
There are still some problems and some improvements we can achieve, though.
For example, the service provider still requires a specific and named repository.
In other words, the service class will depend on a named, concrete class. This makes the class less reusable and our app more fragile and rigid.

Therefore, we need to make the service depends on an abstraction.


<ImageZoom
    src="/posts/dependency-inversion/interface-1400x700.webp"
    width="1400"
    height="700"
    alt="Dependency inversion interface"
/>

<br/>

Let's refactor the code again.

```ts
// OPTION III (✅ ✅ ✅ Best)
// The repository interface makes the service depend on abstraction not a names class.
interface Repository {
    findOne(name: string);
    create(name: string);
    findAll();
}
interface Repository {
    create(email: string, password: string);
    findOne(id: number);
}
export class UsersService {
    usersRepo: Repository;

    constructor(repo: Repository) {
        this.usersRepo = repo;
    }
}
```

Great.
- We created an interface in which methods are determined by the higher-level module `UsersService`.
- The interface also makes the provider more independent, meaning that it doesn't depend on `UsersRepository` anymore. It depends on any repository that satisfies the conditions.



<br/>

Until now, we tried to understand the dependency inversion principle by giving a simple class dependency example and refactoring it. However, what we did was not a structured way of solving the problem. We need more than refactoring, like a framework.


#### Inversion of Control



At this very moment, [Inversion of Control (IoC)](https://en.wikipedia.org/wiki/Inversion_of_control) comes into play for us. It inverts the flow of control as compared to traditional control flow.
Inversion of control is used to increase the modularity of the program and make it extensible.

IoC gives us the ways for inverting the control and Dependency Injection is one of those ways that Nest put it at its core. In other words, Dependency Injection plays a vital role in NestJS.

#### Dependency Injection

Dependency injection is one form of the broader technique of inversion of control.

The intent behind dependency injection is to achieve separation of concerns of construction and use of objects. This can increase readability and code reuse.

Dependency injection solves the following problems:
- How can a class be independent from the creation of the objects it depends on?
- How can the way objects are created be specified in separate configuration files?
- How can an application support different configurations?


A type of IoC where we move the creation and binding of dependency outside of the class that depends on it.

Normally, objects are created inside of the dependent class and bounded inside the dependent class.

Considering the statement above, let's look at our example and other solutions.


### IoC Container or DI Container
IoC container is a framework to create dependencies and pass them when needed. That means we don’t need to manually create dependencies like earlier examples. IoC framework automatically creates objects based on requests and injects them when needed. So it reduces lots of pain. You will be happy when you see all the dependencies created automatically.

<ImageZoom
    src="/posts/dependency-inversion/ioc-container-2800x1400.webp"
    width="2800"
    height="1400"
    alt="Dependency inversion interface"
/>


#### DI container Flow
1. It register all classes with the container when the app bootstraps.
2. The container is going to take a look at all these different classes and figure out which dependencies each one has.
3. We ask container to create an instance of a class for us. (Generally it will be `Controller` class).
4. Container look the dependencies it generated, and creates all the required deps. Then it gives us the instance (`Controller`).
5. Container will hold all the instances of classes and their dependencies. If we are going to create a class that has a dependency already created, DI container returns it rather than create a new instance

In Dependency Injection, the receiving object is called a 'client' and the passed-in ('injected') object is called a 'service'. The code that passes the service to the client is called the 'injector'.
Instead of the client specifying which service it will use, the injector tells the client what service to use. The 'injection' refers to the passing of a dependency (a service) into the client that uses it.


#### How to use DI Container in NestJS
It is very easy in NestJS to make a class injectable. We simply put `@Injectable()` decorator on top of it.

The `@Injectable()` decorator attaches metadata, which declares that CatsService is a class that can be managed by the Nest IoC container.

```ts
import { Injectable } from '@nestjs/common'; // import it

// Put the decorator and make it injectable
@Injectable()
export class UsersService {
    usersRepo: Repository;

    constructor(repo: Repository) {
        this.usersRepo = repo;
    }

	// The rest of your code
}
```

You can also [read this article](https://www.codeproject.com/Articles/538536/A-curry-of-Dependency-Inversion-Principle-DIP-Inve#What%20is%20IoC) about the concepts like DI, IoC, and DI Container.

<br/>

This part of the NestJS tutorial is completed. Before the next post, I'm planning to extend current one.
